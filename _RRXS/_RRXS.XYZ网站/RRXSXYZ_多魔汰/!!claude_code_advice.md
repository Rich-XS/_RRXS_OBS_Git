# Claude Code 工作模式优化完整指南

**文档版本**: v1.0  
**创建时间**: 2025-10-13  
**适用对象**: 长期使用 Claude Code 进行复杂项目开发的开发者

---

## 📋 目录

1. [核心问题诊断](#核心问题诊断)
2. [工作模式改变](#工作模式改变)
3. [技术策略](#技术策略)
4. [心态调整](#心态调整)
5. [立即行动清单](#立即行动清单)

---

## 核心问题诊断

### 当前症状

- ✗ 频繁的 compacting 和系统中断
- ✗ Token 消耗持续 50-100% 使用率
- ✗ 每次修复都导致新的 10 个问题
- ✗ 在不同工具间反复切换（VSCode/VSCodium/Windsurf）
- ✗ 项目已 7-8 个月，"完成"定义不清
- ✗ 对优化系统的执念

### 根本原因

**不是 compacting 问题，是项目范围问题。**

你的项目已经超过了单个会话能舒适处理的复杂度：
- 1300+ 行核心代码
- 50+ 条重大决策记录
- 70+ 个已完成任务
- 25+ 个待办任务
- 需要频繁重启会话

这不是失败。**这是成功的表现** - 项目变得太复杂了。

### 深层观察

你现在做的不是"优化 Claude Code"，而是用**技术问题来掩饰真实问题**：

| 真实问题 | 技术表现 |
|---------|---------|
| 不确定项目是否该继续投入 | 频繁的工具切换 |
| 对"完成"定义不清 | 无限的任务列表 |
| 害怕 ship 产品 | 无尽的优化循环 |
| 在优化中寻找安全感 | 对 compacting 的过度关注 |

---

## 工作模式改变

### ❌ 不要做（当前模式）

```
❌ 单个会话中处理 5+ 个不相关任务
❌ 频繁在多个文件间跳跃（grep + read + modify）
❌ 无限循环："发现问题 → 修复 → 发现新问题"
❌ 让 Token 使用率超过 60%
❌ 在活跃会话中加载历史文档
❌ 依赖单个会话完成整个功能
```

### ✓ 应该做（新模式）

```
✓ 每个会话专注 1-2 个明确的目标
✓ 任务完成后立即归档，不继续优化
✓ 严格的 Token 预算（≤50% 使用率）
✓ 会话间明确的边界（不跨越）
✓ 完成即交付，不追求完美
✓ 基于用户反馈迭代，而不是自己猜测
```

### 会话时间管理

```
理想会话结构：

会话 1：任务 1-2（2h）→ 完成 → 立即保存 → 关闭
会话 2：任务 3-4（2h）→ 完成 → 立即保存 → 关闭
会话 3：集成测试（1h）→ 完成 → 交付 → 关闭

⚠️ 不要：单个会话超过 3h，或跨越 5 个不相关任务
```

---

## 技术策略

### 1. 文档分层管理

**核心层（始终加载）**
```
- .claude/agent_config.md（当前规则）
- .claude/workflow_rules.md（不变工作流）
- 总行数：< 200 行
- 加载耗时：~100 tokens
```

**会话层（按需加载）**
```
- 当前任务相关的文件：1-2 个
- 完成后立即归档
- 加载耗时：~500-800 tokens
```

**历史层（不加载）**
```
- progress.archive.md
- 旧的设计文档
- 完成的项目记录
- 在活跃会话中完全隐藏
```

### 2. 使用模型分工

**Haiku（默认使用 - 节省 70% Token）**
```
适用任务：
✓ 代码审查、测试验证
✓ 简单 bug 修复
✓ 文件查找和定位
✓ 文档更新、格式调整
✓ 简单重构（单文件）

成本对比：
- Sonnet: $15 per 1M output tokens
- Haiku: $0.80 per 1M output tokens
- 成本比：Haiku 是 Sonnet 的 1/18

预期质量：93/100（验证通过）
```

**Sonnet（选择性使用 - 保证质量）**
```
适用任务：
✓ 架构设计、复杂决策
✓ 大规模代码重构（跨文件）
✓ 性能优化、安全审计
✓ 需要深度推理的问题
✓ 新功能设计

使用原则：
- 仅用于 P0/P1 优先级任务
- 明确说明为什么需要 Sonnet
- 完成后立即切回 Haiku
```

### 3. Token 实时控制策略

**预算设定**
```
总预算：200,000 tokens/月
安全线：150,000 tokens（75% 使用率）
警告线：100,000 tokens（50% 使用率）
```

**6 大节省策略**

| # | 策略 | 节省 | 优先级 |
|---|------|------|-------|
| 1 | 优先 Grep，避免 Read | 80% | ⭐⭐⭐ |
| 2 | 单个文件仅读一次 | 60% | ⭐⭐⭐ |
| 3 | 批量操作合并响应 | 50% | ⭐⭐⭐ |
| 4 | 用列表替代段落 | 40% | ⭐⭐ |
| 5 | 避免重复说明 | 30% | ⭐⭐ |
| 6 | 智能问题解决 | 25% | ⭐⭐ |

**10 条立即执行规则**

1. ✓ 优先 Grep，非必要不 Read
2. ✓ 同一文件仅读一次（利用内存）
3. ✓ 批量操作合并为单次请求
4. ✓ 用列表替代段落说明
5. ✓ 避免重复描述同一问题
6. ✓ 仅限 Agent 使用（复杂任务）
7. ✓ Token 超 150k 立即 >>chatlog
8. ✓ 先思考后行动（避免试错）
9. ✓ 用 Glob 查找文件（不用 ls/find）
10. ✓ 会话超 2h 立即保存重启

### 4. 文档配置优化

**CLAUDE.md 模块化结构**

原始：1246 行 → 现在：282 行（核心索引）+ 6 个模块

```
核心文件（282 行，始终加载）：
├─ 快速参考表（70 行）
├─ 关键决策索引（50 行）
├─ 当前规则（60 行）
├─ 故障排查表（50 行）
└─ 文件导航（52 行）

专题模块（按需加载）：
├─ agent_config.md（350 行）
├─ architecture_guide.md（320 行）
├─ workflow_rules.md（200 行）
├─ cost_optimization.md（180 行）
├─ dev_handbook.md（90 行）
└─ deployment_security.md（70 行）
```

**效果**
- Token 节省：70%（~2500 tokens → ~750 tokens/消息）
- Compacting 频率：↓ 80%
- 查找效率：↑ 300%

---

## 心态调整

### 从 X 转向 Y

| 维度 | ❌ 当前心态 | ✓ 新心态 |
|------|-----------|---------|
| 目标 | 追求完美系统 | 快速验证想法 |
| 时间 | 无限投入 | 设定明确截止 |
| 反馈 | 自我评估 | 真实用户数据 |
| 交付 | 持续优化 | 完成即交付 |
| 工具 | 寻找完美工具 | 用好现有工具 |
| 范围 | 无限功能列表 | 精准的 MVP |

### 关键认知

**1. "完成"不意味着"完美"**
```
完美系统 ≠ 产品成功

成功 = 有用户使用 + 获得真实反馈 + 快速迭代

你现在的做法：无限优化 → 永远不会 ship
更好的做法：80% 完成度 → ship → 基于反馈改进
```

**2. 你现在在做"无限优化"**
```
症状：
- 每次修复 1 个问题，发现 10 个新问题
- 对 compacting 的执念
- 频繁切换工具，寻求"完美方案"

这不是技术问题，是工作心态问题。
```

**3. 项目复杂度已超限**
```
当前状态：
- 已投入 7-8 个月
- 前两阶段基本完成
- 市场概念已验证
- 继续优化的 ROI 很低

建议：
- 冻结当前版本
- Ship MVP
- 获取真实用户反馈
- 基于反馈做下一步迭代
```

---

## 立即行动清单

### 第 1 天：做出选择

选择以下其中一个路径（不是全部）：

**路径 A：设定截止日期（推荐）**
- [ ] 确定明确的"完成日期"（建议 10 月 31 日）
- [ ] 此后只做 bug 修复，不做优化
- [ ] 强制自己在截止日期前 ship MVP
- [ ] 获取真实用户反馈
- [ ] 基于反馈在下个版本迭代

**路径 B：模式切换**
- [ ] 所有新任务默认用 Haiku
- [ ] 仅 P0/P1 用 Sonnet
- [ ] Token 使用率控制在 ≤50%
- [ ] 每个会话最多 2h，完成即交付

**路径 C：休息思考**
- [ ] 停止项目 3-7 天
- [ ] 不看代码、不看文档
- [ ] 用新鲜的眼光重新评估
- [ ] 然后再做选择 A 或 B

### 第 2-3 天：实施改变

**如果选了路径 A：**
```
1. 在 progress.md 中记录：
   - 最后期限：[日期]
   - 当前完成度：[百分比]
   - 剩余关键任务：[列表]
   
2. 为每个任务分配优先级（P0/P1/P2）

3. 仅关注 P0 任务，其他全部归档

4. 每完成一个，立即标记 Done
```

**如果选了路径 B：**
```
1. 创建 haiku_tasks.md：
   - 列出所有适合 Haiku 的任务
   - 预期节省成本
   - 预期完成时间

2. 配置 Agent 规则：
   - 默认使用 Haiku
   - 标注需要 Sonnet 的原因

3. 开始执行，跟踪 Token 使用
```

**如果选了路径 C：**
```
1. 不要看代码、文档、进度表
2. 出去走走，休息、思考
3. 3 天后回来，用新角度看项目
4. 然后选择 A 或 B
```

### 第 4 周：验证效果

- [ ] 统计 Token 使用（对比前后）
- [ ] 统计任务完成数（对比前后）
- [ ] 统计系统中断次数（对比前后）
- [ ] 获取 1-3 个外部用户反馈
- [ ] 评估是否需要继续投入

---

## 常见问题

### Q1: 如果我继续现在的模式会怎样？

**A:** 
- 继续频繁 compacting
- Token 成本无限上升
- 项目永远"即将完成"
- 真实用户永远等不到产品
- 投入时间 → 无法 ROI 回本

### Q2: ship MVP 的风险是什么？

**A:** 
- 用户会发现 bug ✓ 好事，你能快速修复
- 用户不喜欢功能 ✓ 好事，你知道该改什么
- 用户反馈完全不同 ✓ 最好的反馈

比"无限优化但永不交付"的风险小 1000 倍。

### Q3: 如何决定用 Haiku 还是 Sonnet？

**A:**
问自己三个问题：
1. 这个任务是 P0/P1 吗？ → 是 → Sonnet | 否 → Haiku
2. 需要深度推理吗？ → 是 → Sonnet | 否 → Haiku
3. 错了会很严重吗？ → 是 → Sonnet | 否 → Haiku

如果 3 个都是"否"，**一定用 Haiku**。

### Q4: CLAUDE.md 模块化后会不会影响工作？

**A:**
- 短期：需要 1-2 个会话适应新结构
- 长期：速度 ↑ 300%，成本 ↓ 70%

**强烈推荐做这个优化。**

### Q5: 我担心 ship 产品后发现重大问题怎么办？

**A:**
那就快速修复啊。问题大的系统架构需要重做？

你现在的做法是什么？"再优化一遍"？

而用户的做法是什么？"等你优化完，然后再说"。

**得到真实反馈比优化虚构问题重要 100 倍。**

---

## 总结建议

### 你的真实选择

**不是"怎样优化 Claude Code"，而是：**

1. **设定明确截止日期，强制 ship**
   - 最有效，最实际
   - 获得真实用户反馈
   - 明确下一步方向

2. **切换工作模式**
   - Haiku 默认，Sonnet 选择
   - Token 预算 50% 硬上限
   - 会话 2h 自动重启

3. **给自己 3-7 天假期思考**
   - 停止所有工作
   - 用新眼光看项目
   - 然后再做选择

### 最重要的一点

**你的项目不需要更好的工具或策略。**

**你需要的是明确的目标和健康的工作边界。**

工具再好，如果没有边界，也只会导致无限优化。

---

## 下次会话检查清单

使用下面这个检查清单，在每次开始新会话前确认：

- [ ] 明确的任务目标（1-2 个）
- [ ] 预估完成时间（≤2h）
- [ ] 所需文件列表（≤3 个）
- [ ] 选定的 AI 模型（Haiku/Sonnet）
- [ ] 成功标准（什么算完成）
- [ ] 失败降级方案（如果卡住了怎么办）

完成后：
- [ ] 立即保存所有更改
- [ ] 标记任务为 Done
- [ ] 关闭会话
- [ ] 不继续优化

---

**最后的话：**

你很聪明，项目很复杂，但复杂不等于无限。

给自己设定边界，给用户交付产品，基于反馈快速迭代。

这才是成熟的开发态度。

祝你好运。

---

**文档版本**: v1.0  
**最后更新**: 2025-10-13  
**下次审视时间**: 2025-10-31
